/**
 * @Author: guiguan
 * @Date:   2017-04-13T12:34:51+10:00
 * @Last modified by:   guiguan
 * @Last modified time: 2018-01-23T11:24:08+11:00
 */

import initStateStore from './initStateStore';

global.DEBUG = process.env.DEBUG === 'true';

/**
 * Print logs generated by app so far
 */
global.printLogs = app => {
  app.client.getMainProcessLogs().then(logs => {
    console.log(logs.join('\n'));
  });
};

/**
 * Config test suite
 *
 * @param {Object} [options={}] - config options
 * @param {boolean} [initStateStore=true] - whether to init state store
 * @param {boolean} [setupFailFastTest=true] - whether to setup fail fast test
 */
export default options => {
  const { initStateStore: _initStateStore = true, setupFailFastTest: _setupFailFastTest = true } =
    options || {};

  // timeout for each test case
  global.jasmine.DEFAULT_TIMEOUT_INTERVAL = global.DEBUG ? 7200000 : 180000;

  _initStateStore && initStateStore();
  _setupFailFastTest && setupFailFastTest();

  process.on('uncaughtException', console.error);
};

export const DELAY_TIMEOUT = 30000;
export const TEST_TEMPLATE = 'src/tests/helpers/json_template.json';

export function setupFailFastTest() {
  const oldTest = global.test;

  /** Fail-fast test */
  const test = (() => {
    let _test;

    const _wrappedFn = async fn => {
      if (!_test.error) {
        return fn().catch(e => {
          // we print error here because those errors generated by `expect` do not have stacktrace
          // which won't get printed correctly by jest runner
          if (e.stack !== 'Error') {
            console.error(e.stack);
          } else {
            console.error(e);
          }
          _test.error = new Error('Previous test case has failed');
          return Promise.reject(new Error('Test case failed'));
        });
      }
      throw _test.error;
    };

    _test = (name, fn) => oldTest(name, _wrappedFn.bind(undefined, fn));
    _test.skip = (name, fn) => oldTest.skip(name, _wrappedFn.bind(undefined, fn));
    _test.only = (name, fn) => oldTest.only(name, _wrappedFn.bind(undefined, fn));

    _test.error = null;

    return _test;
  })();

  global.test = test;
}
